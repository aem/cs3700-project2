#!/usr/bin/python3 -u

from enum import Enum
from json import dumps, loads
from select import select
from socket import AF_UNIX, SOCK_SEQPACKET, socket
from sys import argv

# Maximum receivable packet size, in bytes
MAX_PACKET_SIZE = 1500
# Timeout for selecting ready sockets, in seconds
SELECT_TIMEOUT = 0.2


class PacketType(Enum):
    BPDU = 1
    DATA = 2


class Packet(object):
    def __init__(self, source: str, port: int, dest: str, p_type: PacketType, message: dict):
        self.source = source
        self.port = port
        self.dest = dest
        self.type = p_type
        self.message = message

    def pid(self):
        """Get the packet id"""
        return self.message['id']

    @staticmethod
    def bpdu(source: int, root: int, cost: int):
        """Build a BPDU"""
        return Packet(serialize_address(source),
                      -1,
                      'ffff',
                      PacketType.BPDU,
                      {
                          'id': '1234',
                          'root': serialize_address(root),
                          'cost': cost
        })


class Port(socket):
    def __init__(self, num: int, lan: str):
        super().__init__(AF_UNIX, SOCK_SEQPACKET)

        self.num = num
        self.lan = lan
        self.is_open = True

        self.connect(pad(lan))

    def recv_packet(self) -> Packet:
        print('Receiving on port {}'.format(self.num))
        msg = self.recv(MAX_PACKET_SIZE)

        if not msg:
            print('Got nothing')
            return None

        print('Got something')
        msg_dict = loads(msg.decode('utf-8'))
        packet_type = PacketType[msg_dict['type'].upper()]

        packet = Packet(msg_dict['source'],
                        self.num,
                        msg_dict['dest'],
                        packet_type,
                        msg_dict['message'])

        print('Received {} packet from {}'.format(packet.type.name, packet.source))

        return packet

    def send_packet(self, packet: Packet):
        packet_dict = {
            'source': packet.source,
            'dest': packet.dest,
            'type': packet.type.name.lower(),
            'message': packet.message
        }

        print(packet_dict)
        packet_str = dumps(packet_dict)

        print('Sending {} packet on port {}'.format(packet.type.name, self.num))
        self.sendall(packet_str.encode('utf-8'))


class Bridge(object):
    def __init__(self, bridge_id: str, lans):
        print('Bridge {} starting up'.format(bridge_id))

        self.bridge_id = deserialize_address(bridge_id)
        self.ports = [Port(i, lan) for i, lan in enumerate(lans)]

        self.update_root(self.bridge_id)

    def run(self):
        while True:
            packets = self.read_packets()
            self.process_packets(packets)

    def read_packets(self):
        ready_ports, _, _ = select(self.ports, [], [], SELECT_TIMEOUT)
        packets = [port.recv_packet() for port in ready_ports]
        return [packet for packet in packets if packet]

    def process_packets(self, packets: list):
        bpdus = filter_bpdus(packets)

        self.process_bpdus(bpdus)

        # TODO data packets

    def process_bpdus(self, bpdus: list):
        for bpdu in bpdus:
            self.process_bpdu(bpdu)

    def process_bpdu(self, bpdu: Packet):
        other_root = deserialize_address(bpdu.message['root'])
        if other_root < self.root_bridge:
            self.update_root(other_root)

    def update_root(self, new_root_id: int):
        self.root_bridge = new_root_id
        print('New root: {}/{}'.format(
            serialize_address(self.bridge_id),
            serialize_address(self.root_bridge)))

        # TODO
        self.root_port = None
        self.root_cost = 0

        self.send_bpdus()

    def send_bpdus(self):
        bpdu = self.make_bpdu()

        _, ready_ports, _ = select([], self.ports, [], SELECT_TIMEOUT)
        for port in ready_ports:
            port.send_packet(bpdu)

    def make_bpdu(self) -> Packet:
        return Packet.bpdu(self.bridge_id, self.root_bridge, self.root_cost)


def pad(name: str) -> str:
    """Pads the name with null bytes"""
    return '\0{}{}'.format(name, '\0' * (107 - len(name)))


def deserialize_address(addr: str) -> int:
    """Deserialize the hex address into a decimal number"""
    return int(addr, 16)


def serialize_address(addr: int) -> str:
    """Serialize the decimal address into a hex string"""
    return '{:04x}'.format(addr)


def filter_bpdus(packets):
    """Get all the BPDUs"""
    return filter_packets_by_type(packets, PacketType.BPDU)


def filter_packets_by_type(packets, packet_type: PacketType):
    """Get all the packets of the given type"""
    return [packet for packet in packets if packet.type is packet_type]


def lowest_bpdu(bpdus) -> Packet:
    """
    Get the lowest BPDU
    """
    if not bpdus:
        return None

    low_bpdu = bpdus[0]
    for bpdu in bpdus[1:]:
        if bpdu_less_than(bpdu, low_bpdu):
            low_bpdu = bpdu

    return low_bpdu


def bpdu_less_than(bpdu1: Packet, bpdu2: Packet) -> bool:
    """
    Is bpdu1 less than bpdu2?
    """
    msg1 = bpdu1.message
    msg2 = bpdu2.message

    return (deserialize_address(msg1['root']) < deserialize_address(msg2['root']) or
            msg1['cost'] < msg2['cost'] or
            deserialize_address(msg1['id']) < deserialize_address(msg2['id']))


if __name__ == '__main__':
    BRIDGE = Bridge(argv[1], argv[2:])
    BRIDGE.run()
