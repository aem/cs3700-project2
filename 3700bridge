#!/usr/bin/python3 -u

from enum import Enum
from json import dumps, loads
from select import select
from socket import AF_UNIX, SOCK_SEQPACKET, socket
from sys import argv
from time import time

# The minimum interval between BPDU sends, in seconds
MIN_BPDU_INTERVAL = 0.5
# Maximum receivable packet size, in bytes
MAX_PACKET_SIZE = 1500
# Timeout for selecting ready sockets, in seconds
SELECT_TIMEOUT = 0.2


class PacketType(Enum):
    BPDU = 1
    DATA = 2


class Packet(object):
    def __init__(self, source: str, sent_port: int, recvd_port: int, dest: str, p_type: PacketType, message: dict):
        self.source = source
        self.sent_port = sent_port
        self.recvd_port = recvd_port
        self.dest = dest
        self.type = p_type
        self.message = message

    def pid(self):
        """Get the packet id"""
        return self.message['id']

    @staticmethod
    def bpdu(source: int, root: int, cost: int):
        """Build a BPDU"""
        return Packet(serialize_address(source),
                      -1,
                      -1,
                      'ffff',
                      PacketType.BPDU,
                      {'id': '1234', 'root': serialize_address(root), 'cost': cost})


class Port(socket):
    def __init__(self, num: int, lan: str):
        super().__init__(AF_UNIX, SOCK_SEQPACKET)

        self.num = num
        self.lan = lan
        self.is_open = True

        self.connect(pad(lan))

    def recv_packet(self) -> Packet:
        msg = self.recv(MAX_PACKET_SIZE)

        if not msg:
            return None

        msg_dict = loads(msg.decode('utf-8'))
        packet_type = PacketType[msg_dict['type'].upper()]

        packet = Packet(msg_dict['source'],
                        msg_dict.get('port', -1),
                        self.num,
                        msg_dict['dest'],
                        packet_type,
                        msg_dict['message'])

        print('Received {} packet from {}'.format(
            packet.type.name, packet.source))

        return packet

    def send_packet(self, packet: Packet):
        packet_dict = {
            'source': packet.source,
            'dest': packet.dest,
            'type': packet.type.name.lower(),
            'message': packet.message,
            'port': self.num
        }

        packet_str = dumps(packet_dict)

        print('Sending {} packet on port {}'.format(packet.type.name, self.num))
        self.sendall(packet_str.encode('utf-8'))


class Bridge(object):
    def __init__(self, bridge_id: str, lans):
        print('Bridge {} starting up'.format(bridge_id))

        self.bridge_id = deserialize_address(bridge_id)
        self.ports = [Port(i, lan) for i, lan in enumerate(lans)]

        self.last_bpdu_send = 0
        self.update_root(self.bridge_id, None, None, 0)

        self.bpdus = {port.num: [] for port in self.ports}

    def run(self):
        while True:
            packets = self.read_packets()
            self.process_packets(packets)

            print([port.lan for port in self.ports if port.is_open])

            self.send_bpdus()

    def read_packets(self):
        ready_ports, _, _ = select(self.ports, [], [], SELECT_TIMEOUT)
        packets = [port.recv_packet() for port in ready_ports]
        return [packet for packet in packets if packet]

    def process_packets(self, packets: list):
        bpdus = filter_bpdus(packets)

        self.process_bpdus(bpdus)

        # TODO data packets

    def process_bpdus(self, bpdus: list):
        for bpdu in bpdus:
            self.process_bpdu(bpdu)

        self.designate_ports()

    def process_bpdu(self, bpdu: Packet):
        other_root = deserialize_address(bpdu.message['root'])
        other_cost = bpdu.message['cost']
        other_id = deserialize_address(bpdu.source)

        if other_root < self.root_bridge:
            self.update_root(other_root, other_id, bpdu.recvd_port, other_cost + 1)
        elif other_root == self.root_bridge and other_cost < (self.root_cost - 1):
            self.update_next_bridge(other_id, bpdu.recvd_port, other_cost + 1)

        self.bpdus[bpdu.recvd_port].append(bpdu)

    def update_root(self, new_root_id: int, new_next_bridge: int, new_root_port: int, new_root_cost: int):
        self.root_bridge = new_root_id
        self.update_next_bridge(new_next_bridge, new_root_port, new_root_cost)

        print('New root: {}/{}'.format(
            serialize_address(self.bridge_id),
            serialize_address(self.root_bridge)))

        self.send_bpdus(True)

    def update_next_bridge(self, new_next_bridge: int, new_root_port: int, new_root_cost: int):
        self.next_bridge = new_next_bridge
        self.root_port = new_root_port
        self.root_cost = new_root_cost

    def send_bpdus(self, ignore_time=False):
        if not ignore_time and (time() - self.last_bpdu_send < MIN_BPDU_INTERVAL):
            return

        bpdu = self.make_bpdu()

        _, ready_ports, _ = select([], self.ports, [], SELECT_TIMEOUT)
        for port in ready_ports:
            port.send_packet(bpdu)

        self.last_bpdu_send = time()

    def designate_ports(self):
        for port_num, bpdus in self.bpdus.items():
            self.clean_stale_bpdus(bpdus)

            if port_num == self.root_port:
                continue

            from_me = [bpdu for bpdu in bpdus if deserialize_address(bpdu.source) == self.bridge_id]
            active = True

            if from_me:
                min_sent_port = min([bpdu.sent_port for bpdu in from_me])
                print('Port: {}, Min: {}'.format(port_num, min_sent_port))
                active &= port_num < min_sent_port
                print('Active (self-connected): {}'.format(active))

            not_from_me = [bpdu for bpdu in bpdus if deserialize_address(bpdu.source) != self.bridge_id]
            low_bpdu = lowest_bpdu(not_from_me)

            if low_bpdu:
                active &= bpdu_less_than(self.make_bpdu(), low_bpdu)
                print('Active (lowest BPDU): {}'.format(active))

            print('Active: {}'.format(active))
            self.ports[port_num].is_open = active

    def clean_stale_bpdus(self, bpdus: list):
        to_remove = []

        for i, bpdu in enumerate(bpdus):
            if deserialize_address(bpdu.message['root']) != self.root_bridge:
                to_remove.append(i)

        for i in to_remove:
            del bpdus[i]

    def make_bpdu(self) -> Packet:
        return Packet.bpdu(self.bridge_id, self.root_bridge, self.root_cost)


def pad(name: str) -> str:
    """Pads the name with null bytes"""
    return '\0{}{}'.format(name, '\0' * (107 - len(name)))


def deserialize_address(addr: str) -> int:
    """Deserialize the hex address into a decimal number"""
    return int(addr, 16)


def serialize_address(addr: int) -> str:
    """Serialize the decimal address into a hex string"""
    return '{:04x}'.format(addr)


def filter_bpdus(packets):
    """Get all the BPDUs"""
    return filter_packets_by_type(packets, PacketType.BPDU)


def filter_packets_by_type(packets, packet_type: PacketType):
    """Get all the packets of the given type"""
    return [packet for packet in packets if packet.type is packet_type]


def lowest_bpdu(bpdus) -> Packet:
    """
    Get the lowest BPDU
    """
    if not bpdus:
        return None

    low_bpdu = bpdus[0]
    for bpdu in bpdus[1:]:
        if bpdu_less_than(bpdu, low_bpdu):
            low_bpdu = bpdu

    return low_bpdu


def bpdu_less_than(bpdu1: Packet, bpdu2: Packet) -> bool:
    """
    Is bpdu1 less than bpdu2?
    """
    msg1 = bpdu1.message
    msg2 = bpdu2.message

    return (deserialize_address(msg1['root']) < deserialize_address(msg2['root']) or
            msg1['cost'] < msg2['cost'] or
            deserialize_address(msg1['id']) < deserialize_address(msg2['id']))


if __name__ == '__main__':
    BRIDGE = Bridge(argv[1], argv[2:])
    BRIDGE.run()
