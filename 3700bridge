#!/usr/bin/python3 -u

from collections import namedtuple
from json import loads
from select import select
from socket import socket, AF_UNIX, SOCK_SEQPACKET

SELECT_TIMEOUT = 0.1
MAX_PACKET_SIZE = 1500


class Packet(object):
    def __init__(self, source, port, dest, p_type, message):
        self.source = source
        self.port = port
        self.dest = dest
        self.type = p_type
        self.message = message

    def id(self):
        return self.message['id']


class Port(socket):
    def __init__(self, num: int, lan: str):
        super().__init__(AF_UNIX, SOCK_SEQPACKET)

        self.num = num
        self.lan = lan
        self.is_open = True

        self.connect(pad(lan))

    def recv_packet(self) -> Packet:
        msg = self.recv(MAX_PACKET_SIZE)
        msg_dict = loads(msg.decode('utf-8'))

        return Packet(msg_dict['source'], self.num, msg_dict['dest'],
                      msg_dict['type'], msg_dict['message'])

    def send_packet(self, packet):
        pass

class RoutingEntry(object):
    def init(self, port_id: int):
        self.port_id = port_id
        self.ttl = 5


class Bridge(object):
    def __init__(self, bridge_id: str, lans):
        print('Bridge {} starting up'.format(bridge_id))

        self.bridge_id = deserialize_address(bridge_id)
        self.ports = [Port(i, lan) for i, lan in enumerate(lans)]
        self.update_root(self.bridge_id, None, 0)
        self.routing_table = dict()

    def reset_routing_table(self):
        self.routing_table = dict()

    def update_root(self, root_bridge: str, root_port: int, root_cost: int):
        self.root_bridge = root_bridge
        self.reset_routing_table
        print('New root: {}/{}'.format(serialize_address(self.bridge_id), root_bridge))

        self.update_root_port(root_port, root_cost)

    def update_root_port(self, root_port: int, root_cost: int):
        self.root_port = root_port
        self.root_cost = root_cost
        print('Root port: {}/{}'.format(serialize_address(self.bridge_id), root_port))

    def run(self):
        while True:
            packets = self.read_packets()

    def process_data_packet(self, packet):
        print('Received message {}, on port {} from {} to {}').format(packet.id(), packet.port, packet.source, packet.dest)
        self.update_routing_table(packet)
        self.process_packet(packet)

    def update_routing_table(self, packet):
        self.routing_table[packet.source] = RoutingEntry(port=packet.port)

    def process_packet(self, packet):
        if self.routing_table.get(packet.dest):
            port = self.ports.get(self.routing_table[packet.dest].port)
            if port and port.is_open:
                self.forward_packet(packet)
            else:
                self.drop_packet(packet)
        else:
            self.broadcast_packet(packet)

    def forward_packet(self, packet):
        print('Forwarding message {} to port {}').format(packet.id(), packet.port)
        port = self.ports[packet.port]
        port.send_packet(packet)

    def broadcast_packet(self, packet):
        print('Broadcasting message {} to all ports').format(packet.id())
        for port in self.ports:
            if port.is_open:
                port.send_packet(packet)

    def drop_packet(self, packet):
        print('Not forwarding packet {}').format(packet.id())

    def read_packets(self):
        ready_ports, _, _ = select(self.ports, [], [], SELECT_TIMEOUT)
        return [port.recv_packet() for port in ready_ports]


def pad(name):
    """
    Pads the name with null bytes
    """
    return '\0{}{}'.format(name, '\0' * (107 - len(name)))


def deserialize_address(addr: str) -> int:
    """
    Deserialize the hex address into a decimal number
    """
    return int(addr, 16)


def serialize_address(addr: int) -> str:
    """
    Serialize the decimal address into a hex string
    """
    return hex(addr)[2:]
