#!/usr/bin/python3 -u

from collections import namedtuple
from enum import Enum, auto
from json import loads
from select import select
from socket import socket, AF_UNIX, SOCK_SEQPACKET

SELECT_TIMEOUT = 0.1
MAX_PACKET_SIZE = 1500


class PacketType(Enum):
    BPDU = auto()
    DATA = auto()


Packet = namedtuple('Packet', ['source', 'port', 'dest', 'type', 'message'])


class Port(socket):
    def __init__(self, num: int, lan: str):
        super().__init__(AF_UNIX, SOCK_SEQPACKET)

        self.num = num
        self.lan = lan
        self.is_open = True

        self.connect(pad(lan))

    def recv_packet(self) -> Packet:
        msg = self.recv(MAX_PACKET_SIZE)
        msg_dict = loads(msg.decode('utf-8'))

        packet_type = PacketType.BPDU if msg_dict['type'] == 'BPDU' else PacketType.DATA

        return Packet(msg_dict['source'], self.num, msg_dict['dest'],
                      packet_type, msg_dict['message'])


class Bridge(object):
    def __init__(self, bridge_id: str, lans):
        print('Bridge {} starting up'.format(bridge_id))

        self.bridge_id = deserialize_address(bridge_id)
        self.ports = [Port(i, lan) for i, lan in enumerate(lans)]
        self.update_root(self.bridge_id, None, 0)

    def update_root(self, root_bridge: str, root_port: int, root_cost: int):
        self.root_bridge = root_bridge
        print('New root: {}/{}'.format(serialize_address(self.bridge_id), root_bridge))

        self.update_root_port(root_port, root_cost)

    def update_root_port(self, root_port: int, root_cost: int):
        self.root_port = root_port
        self.root_cost = root_cost
        print('Root port: {}/{}'.format(serialize_address(self.bridge_id), root_port))

    def run(self):
        while True:
            packets = self.read_packets()

    def read_packets(self):
        ready_ports, _, _ = select(self.ports, [], [], SELECT_TIMEOUT)
        return [port.recv_packet() for port in ready_ports]


def pad(name):
    """
    Pads the name with null bytes
    """
    return '\0{}{}'.format(name, '\0' * (107 - len(name)))


def deserialize_address(addr: str) -> int:
    """
    Deserialize the hex address into a decimal number
    """
    return int(addr, 16)


def serialize_address(addr: int) -> str:
    """
    Serialize the decimal address into a hex string
    """
    return hex(addr)[2:]
