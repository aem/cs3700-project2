#!/usr/bin/python3 -u

from collections import namedtuple
from enum import Enum
from json import loads, dumps
from select import select
from socket import socket, AF_UNIX, SOCK_SEQPACKET
from datetime import datetime
from time import sleep

SELECT_TIMEOUT = 0.1
MAX_PACKET_SIZE = 1500
MIN_THREAD_SLEEP = 0.5


class PacketType(Enum):
    BPDU = 1
    DATA = 2

class Packet(object):
    def __init__(self, source: str, port: int, dest: str, p_type: PacketType, message: dict):
        self.source = source
        self.port = port
        self.dest = dest
        self.type = p_type
        self.message = message

    def id(self):
        return self.message['id']

    @staticmethod
    def bpdu(source: str, root: int, cost: int):
        return Packet(source, -1, 'ffff', PacketType.BPDU, {'id': '1234', 'root': serialize_address(root), 'cost': cost})


class Port(socket):
    def __init__(self, num: int, lan: str):
        super().__init__(AF_UNIX, SOCK_SEQPACKET)

        self.num = num
        self.lan = lan
        self.is_open = True

        self.connect(pad(lan))

    def recv_packet(self) -> Packet:
        msg = self.recv(MAX_PACKET_SIZE)
        msg_dict = loads(msg.decode('utf-8'))

        packet_type = PacketType[msg_dict['type'].upper()]

        return Packet(msg_dict['source'], self.num, msg_dict['dest'],
                      packet_type, msg_dict['message'])

    def send_packet(self, packet: Packet):
        packet_dict = {
            'source': packet.source,
            'dest': packet.dest,
            'type': packet.type.name.lower(),
            'message': packet.message
        }

        packet_str = dumps(packet_dict)
        self.sendall(packet_str.encode('utf-8'))


class RoutingEntry(object):
    def init(self, port_id: int):
        self.port_id = port_id
        self.created_at = datetime.utcnow()


class Bridge(object):
    def __init__(self, bridge_id: str, lans):
        print('Bridge {} starting up'.format(bridge_id))

        self.bridge_id = deserialize_address(bridge_id)
        self.ports = [Port(i, lan) for i, lan in enumerate(lans)]
        self.update_root(self.bridge_id, None, 0)
        self.routing_table = dict()

    def reset_routing_table(self):
        self.routing_table = dict()

    def update_root(self, root_bridge: str, root_port: int, root_cost: int):
        self.root_bridge = root_bridge
        self.reset_routing_table()
        print('New root: {}/{}'.format(serialize_address(self.bridge_id), root_bridge))

        self.update_root_port(root_port, root_cost)

    def update_root_port(self, root_port: int, root_cost: int):
        self.root_port = root_port
        self.root_cost = root_cost
        print('Root port: {}/{}'.format(serialize_address(self.bridge_id), root_port))

    def run(self):
        last_cycle = datetime.utcnow()
        while True:
            since_last_run = (datetime.utcnow() - last_cycle).total_seconds()
            if (since_last_run < MIN_THREAD_SLEEP):
                sleep(MIN_THREAD_SLEEP - since_last_run)
            last_cycle = datetime.utcnow()

            packets = self.read_packets()
            bpdus = filter_bpdus(packets)
            data = filter_data(packets)

            self.update_routing_table_ttls()
            self.process_bpdus(bpdus)
            for packet in data:
                self.process_data_packet(packet)
            self.send_bpdus()

    def process_data_packet(self, packet):
        print('Received message {}, on port {} from {} to {}').format(packet.id(), packet.port, packet.source, packet.dest)
        self.update_routing_table(packet)
        self.process_packet(packet)

    def update_routing_table(self, packet):
        self.routing_table[packet.source] = RoutingEntry(packet.port)

    def update_routing_table_ttls(self):
        for bridge, entry in self.routing_table:
            if (datetime.utcnow() - entry.created_at).total_seconds() > 5:
                self.routing_table.pop(bridge, False)

    def process_packet(self, packet):
        if self.routing_table.get(packet.dest):
            port = self.ports.get(self.routing_table[packet.dest].port)
            if port and port.is_open:
                self.forward_packet(packet, port)
            else:
                self.drop_packet(packet)
        else:
            self.broadcast_packet(packet)

    def forward_packet(self, packet, port):
        print('Forwarding message {} to port {}').format(packet.id(), port.num)
        port.send_packet(packet)

    def broadcast_packet(self, packet):
        print('Broadcasting message {} to all ports').format(packet.id())
        for port in self.ports:
            if port.is_open:
                port.send_packet(packet)

    def drop_packet(self, packet):
        print('Not forwarding packet {}').format(packet.id())

    def process_bpdus(self, bpdus):
        if not bpdus:
            return

        low_bpdu = bpdus[0]
        for bpdu in bpdus[1:]:
            if bpdu_less_than(bpdu, low_bpdu):
                low_bpdu = bpdu
        # TODO

    def read_packets(self):
        ready_ports, _, _ = select(self.ports, [], [], SELECT_TIMEOUT)
        return [port.recv_packet() for port in ready_ports]

    def send_bpdus(self):
        _, ready_ports, _, _ = select([], self.ports, [], SELECT_TIMEOUT)
        for port in ready_ports:
            port.send_packet(Packet.bpdu(self.bridge_id, self.root_bridge, self.root_cost))


def pad(name):
    """
    Pads the name with null bytes
    """
    return '\0{}{}'.format(name, '\0' * (107 - len(name)))


def deserialize_address(addr: str) -> int:
    """
    Deserialize the hex address into a decimal number
    """
    return int(addr, 16)


def serialize_address(addr: int) -> str:
    """
    Serialize the decimal address into a hex string
    """
    return hex(addr)[2:]


def filter_bpdus(packets):
    """
    Get all the BPDUs
    """
    return filter_packets_by_type(packets, PacketType.BPDU)


def filter_data(packets):
    """
    Get all the data packets
    """
    return filter_packets_by_type(packets, PacketType.DATA)


def filter_packets_by_type(packets, packet_type: PacketType):
    """
    Get all the packets of the given type
    """
    return [packet for packet in packets if packet.type is packet_type]


def bpdu_less_than(bpdu1: Packet, bpdu2: Packet) -> bool:
    """
    Is bpdu1 less than bpdu2?
    """
    msg1 = bpdu1.message
    msg2 = bpdu2.message

    # TODO
    return (msg1['root'])
